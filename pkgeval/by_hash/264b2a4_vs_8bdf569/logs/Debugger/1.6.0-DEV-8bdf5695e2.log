Julia Version 1.6.0-DEV.918
Commit 8bdf5695e2 (2020-09-15 16:48 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: Intel(R) Xeon(R) Silver 4114 CPU @ 2.20GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_DEPOT_PATH = ::/usr/local/share/julia
  JULIA_NUM_THREADS = 2

  Resolving package versions...
[ Info: LEGAL NOTICE: package operations send anonymous data about your system to https://pkg.julialang.org (your current package server), including the operating system and Julia versions you are using, and a random client UUID. Running `Pkg.telemetryinfo()` will show exactly what data is sent. See https://julialang.org/legal/data/ for more details about what this data is used for, how long it is retained, and how to opt out of sending it.
  Installed Crayons ───────────── v4.0.4
  Installed CodeTracking ──────── v1.0.2
  Installed Debugger ──────────── v0.6.6
  Installed JuliaInterpreter ──── v0.8.0
  Installed DocStringExtensions ─ v0.8.3
  Installed Highlights ────────── v0.4.5
Updating `~/.julia/environments/v1.6/Project.toml`
  [31a5f54b] + Debugger v0.6.6
Updating `~/.julia/environments/v1.6/Manifest.toml`
  [da1fd8a2] + CodeTracking v1.0.2
  [a8cc5b0e] + Crayons v4.0.4
  [31a5f54b] + Debugger v0.6.6
  [ffbed154] + DocStringExtensions v0.8.3
  [eafb193a] + Highlights v0.4.5
  [aa1ae85d] + JuliaInterpreter v0.8.0
  [2a0f44e3] + Base64
  [ade2ca70] + Dates
  [8ba89e20] + Distributed
  [b77e0a4c] + InteractiveUtils
  [76f85450] + LibGit2
  [8f399da3] + Libdl
  [56ddb016] + Logging
  [d6f4376e] + Markdown
  [44cfe95a] + Pkg
  [de0858da] + Printf
  [3fa0cd96] + REPL
  [9a3f8284] + Random
  [ea8e919c] + SHA
  [9e88b42a] + Serialization
  [6462fe0b] + Sockets
  [fa267f1f] + TOML
  [8dfed614] + Test
  [cf7118a7] + UUIDs
  [4ec0a83e] + Unicode
    Testing Debugger
Status `/tmp/jl_6pagYu/Project.toml`
  [da1fd8a2] CodeTracking v1.0.2
  [a8cc5b0e] Crayons v4.0.4
  [31a5f54b] Debugger v0.6.6
  [eafb193a] Highlights v0.4.5
  [aa1ae85d] JuliaInterpreter v0.8.0
  [98bfdc55] TerminalRegressionTests v0.2.0
  [b77e0a4c] InteractiveUtils
  [d6f4376e] Markdown
  [3fa0cd96] REPL
  [8dfed614] Test
Status `/tmp/jl_6pagYu/Manifest.toml`
  [da1fd8a2] CodeTracking v1.0.2
  [3da002f7] ColorTypes v0.10.9
  [a8cc5b0e] Crayons v4.0.4
  [31a5f54b] Debugger v0.6.6
  [ab62b9b5] DeepDiffs v1.2.0
  [ffbed154] DocStringExtensions v0.8.3
  [53c48c17] FixedPointNumbers v0.5.3
  [eafb193a] Highlights v0.4.5
  [aa1ae85d] JuliaInterpreter v0.8.0
  [98bfdc55] TerminalRegressionTests v0.2.0
  [7774df62] VT100 v0.3.2
  [2a0f44e3] Base64
  [ade2ca70] Dates
  [8ba89e20] Distributed
  [b77e0a4c] InteractiveUtils
  [76f85450] LibGit2
  [8f399da3] Libdl
  [56ddb016] Logging
  [d6f4376e] Markdown
  [44cfe95a] Pkg
  [de0858da] Printf
  [3fa0cd96] REPL
  [9a3f8284] Random
  [ea8e919c] SHA
  [9e88b42a] Serialization
  [6462fe0b] Sockets
  [fa267f1f] TOML
  [8dfed614] Test
  [cf7118a7] UUIDs
  [4ec0a83e] Unicode
    Testing Running tests...
Test Failed at /home/pkgeval/.julia/packages/Debugger/W9gho/test/misc.jl:60
  Expression: occursin("handle_message(logger, level, msg", body)
   Evaluated: occursin("handle_message(logger, level, msg", "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule CoreLogging\n\nimport Base: isless, +, -, convert, show\n\nexport\n    AbstractLogger,\n    LogLevel,\n    NullLogger,\n    @debug,\n    @info,\n    @warn,\n    @error,\n    @logmsg,\n    with_logger,\n    current_logger,\n    global_logger,\n    disable_logging,\n    SimpleLogger\n\n#-------------------------------------------------------------------------------\n# The AbstractLogger interface\n\"\"\"\nA logger controls how log records are filtered and dispatched.  When a log\nrecord is generated, the logger is the first piece of user configurable code\nwhich gets to inspect the record and decide what to do with it.\n\"\"\"\nabstract type AbstractLogger ; end\n\n\"\"\"\n    handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\n\nLog a message to `logger` at `level`.  The logical location at which the\nmessage was generated is given by module `_module` and `group`; the source\nlocation by `file` and `line`. `id` is an arbitrary unique value (typically a\n[`Symbol`](@ref)) to be used as a key to identify the log statement when\nfiltering.\n\"\"\"\nfunction handle_message end\n\n\"\"\"\n    shouldlog(logger, level, _module, group, id)\n\nReturn true when `logger` accepts a message at `level`, generated for\n`_module`, `group` and with unique log identifier `id`.\n\"\"\"\nfunction shouldlog end\n\n\"\"\"\n    min_enabled_level(logger)\n\nReturn the minimum enabled level for `logger` for early filtering.  That is,\nthe log level below or equal to which all messages are filtered.\n\"\"\"\nfunction min_enabled_level end\n\n\"\"\"\n    catch_exceptions(logger)\n\nReturn true if the logger should catch exceptions which happen during log\nrecord construction.  By default, messages are caught\n\nBy default all exceptions are caught to prevent log message generation from\ncrashing the program.  This lets users confidently toggle little-used\nfunctionality - such as debug logging - in a production system.\n\nIf you want to use logging as an audit trail you should disable this for your\nlogger type.\n\"\"\"\ncatch_exceptions(logger) = true\n\n\n# Prevent invalidation when packages define custom loggers\n# Using invoke in combination with @nospecialize eliminates backedges to these methods\nfunction _invoked_shouldlog(logger, level, _module, group, id)\n    @nospecialize\n    return invoke(\n        shouldlog,\n        Tuple{typeof(logger), typeof(level), typeof(_module), typeof(group), typeof(id)},\n        logger, level, _module, group, id\n    )\nend\n\nfunction _invoked_min_enabled_level(@nospecialize(logger))\n    return invoke(min_enabled_level, Tuple{typeof(logger)}, logger)\nend\n\nfunction _invoked_catch_exceptions(@nospecialize(logger))\n    return invoke(catch_exceptions, Tuple{typeof(logger)}, logger)\nend\n\n\"\"\"\n    NullLogger()\n\nLogger which disables all messages and produces no output - the logger\nequivalent of /dev/null.\n\"\"\"\nstruct NullLogger <: AbstractLogger; end\n\nmin_enabled_level(::NullLogger) = AboveMaxLevel\nshouldlog(::NullLogger, args...) = false\nhandle_message(::NullLogger, args...; kwargs...) =\n    error(\"Null logger handle_message() should not be called\")\n\n\n#-------------------------------------------------------------------------------\n# Standard log levels\n\"\"\"\n    LogLevel(level)\n\nSeverity/verbosity of a log record.\n\nThe log level provides a key against which potential log records may be\nfiltered, before any other work is done to construct the log record data\nstructure itself.\n\n# Examples\n```\njulia> Logging.LogLevel(0) == Logging.Info\ntrue\n```\n\"\"\"\nstruct LogLevel\n    level::Int32\nend\n\nLogLevel(level::LogLevel) = level\n\nisless(a::LogLevel, b::LogLevel) = isless(a.level, b.level)\n+(level::LogLevel, inc::Integer) = LogLevel(level.level+inc)\n-(level::LogLevel, inc::Integer) = LogLevel(level.level-inc)\nconvert(::Type{LogLevel}, level::Integer) = LogLevel(level)\n\nconst BelowMinLevel = LogLevel(-1000001)\nconst Debug         = LogLevel(   -1000)\nconst Info          = LogLevel(       0)\nconst Warn          = LogLevel(    1000)\nconst Error         = LogLevel(    2000)\nconst AboveMaxLevel = LogLevel( 1000001)\n\nfunction show(io::IO, level::LogLevel)\n    if     level == BelowMinLevel  print(io, \"BelowMinLevel\")\n    elseif level == Debug          print(io, \"Debug\")\n    elseif level == Info           print(io, \"Info\")\n    elseif level == Warn           print(io, \"Warn\")\n    elseif level == Error          print(io, \"Error\")\n    elseif level == AboveMaxLevel  print(io, \"AboveMaxLevel\")\n    else                           print(io, \"LogLevel(\$(level.level))\")\n    end\nend\n\n\n#-------------------------------------------------------------------------------\n# Logging macros\n\n_logmsg_docs = \"\"\"\n    @debug message  [key=value | value ...]\n    @info  message  [key=value | value ...]\n    @warn  message  [key=value | value ...]\n    @error message  [key=value | value ...]\n\n    @logmsg level message [key=value | value ...]\n\nCreate a log record with an informational `message`.  For convenience, four\nlogging macros `@debug`, `@info`, `@warn` and `@error` are defined which log at\nthe standard severity levels `Debug`, `Info`, `Warn` and `Error`.  `@logmsg`\nallows `level` to be set programmatically to any `LogLevel` or custom log level\ntypes.\n\n`message` should be an expression which evaluates to a string which is a human\nreadable description of the log event.  By convention, this string will be\nformatted as markdown when presented.\n\nThe optional list of `key=value` pairs supports arbitrary user defined\nmetadata which will be passed through to the logging backend as part of the\nlog record.  If only a `value` expression is supplied, a key representing the\nexpression will be generated using [`Symbol`](@ref). For example, `x` becomes `x=x`,\nand `foo(10)` becomes `Symbol(\"foo(10)\")=foo(10)`.  For splatting a list of\nkey value pairs, use the normal splatting syntax, `@info \"blah\" kws...`.\n\nThere are some keys which allow automatically generated log data to be\noverridden:\n\n  * `_module=mod` can be used to specify a different originating module from\n    the source location of the message.\n  * `_group=symbol` can be used to override the message group (this is\n    normally derived from the base name of the source file).\n  * `_id=symbol` can be used to override the automatically generated unique\n    message identifier.  This is useful if you need to very closely associate\n    messages generated on different source lines.\n  * `_file=string` and `_line=integer` can be used to override the apparent\n    source location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\n  * `maxlog=integer` should be used as a hint to the backend that the message\n    should be displayed no more than `maxlog` times.\n  * `exception=ex` should be used to transport an exception with a log message,\n    often used with `@error`. An associated backtrace `bt` may be attached\n    using the tuple `exception=(ex,bt)`.\n\n# Examples\n\n```\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = \\\$sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = \\\$i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n```\n\"\"\"\n\n# Get (module,filepath,line) for the location of the caller of a macro.\n# Designed to be used from within the body of a macro.\nmacro _sourceinfo()\n    esc(quote\n        (__module__,\n         __source__.file === nothing ? \"?\" : String(__source__.file::Symbol),\n         __source__.line)\n    end)\nend\n\nmacro logmsg(level, exs...) logmsg_code((@_sourceinfo)..., esc(level), exs...) end\nmacro debug(exs...) logmsg_code((@_sourceinfo)..., :Debug, exs...) end\nmacro  info(exs...) logmsg_code((@_sourceinfo)..., :Info,  exs...) end\nmacro  warn(exs...) logmsg_code((@_sourceinfo)..., :Warn,  exs...) end\nmacro error(exs...) logmsg_code((@_sourceinfo)..., :Error, exs...) end\n\n# Logging macros share documentation\n@eval @doc \$_logmsg_docs :(@logmsg)\n@eval @doc \$_logmsg_docs :(@debug)\n@eval @doc \$_logmsg_docs :(@info)\n@eval @doc \$_logmsg_docs :(@warn)\n@eval @doc \$_logmsg_docs :(@error)\n\n_log_record_ids = Set{Symbol}()\n# Generate a unique, stable, short, somewhat human readable identifier for a\n# logging *statement*. The idea here is to have a key against which log events\n# can be filtered and otherwise manipulated. The key should uniquely identify\n# the source location in the originating module, but ideally should be stable\n# across versions of the originating module, provided the log generating\n# statement itself doesn't change.\nfunction log_record_id(_module, level, message, log_kws)\n    modname = _module === nothing ?  \"\" : join(fullname(_module), \"_\")\n    # Use an arbitrarily chosen eight hex digits here. TODO: Figure out how to\n    # make the id exactly the same on 32 and 64 bit systems.\n    h = UInt32(hash(string(modname, level, message, log_kws)) & 0xFFFFFFFF)\n    while true\n        id = Symbol(modname, '_', string(h, base = 16, pad = 8))\n        # _log_record_ids is a registry of log record ids for use during\n        # compilation, to ensure uniqueness of ids.  Note that this state will\n        # only persist during module compilation so it will be empty when a\n        # precompiled module is loaded.\n        if !(id in _log_record_ids)\n            push!(_log_record_ids, id)\n            return id\n        end\n        h += 1\n    end\nend\n\ndefault_group(file) = Symbol(splitext(basename(file))[1])\n\n# Generate code for logging macros\nfunction logmsg_code(_module, file, line, level, message, exs...)\n    log_data = process_logmsg_exs(_module, file, line, level, message, exs...)\n    quote\n    let\n        level = \$level\n        std_level = convert(LogLevel, level)\n        if std_level >= getindex(_min_enabled_level)\n            group = \$(log_data._group)\n            _module = \$(log_data._module)\n            logger = current_logger_for_env(std_level, group, _module)\n            if !(logger === nothing)\n                id = \$(log_data._id)\n                # Second chance at an early bail-out (before computing the message),\n                # based on arbitrary logger-specific logic.\n                if _invoked_shouldlog(logger, level, _module, group, id)\n                    file = \$(log_data._file)\n                    line = \$(log_data._line)\n                    try\n                        msg = \$(esc(message))\n                        handle_message(\n                            logger, level, msg, _module, group, id, file, line;\n                            \$(log_data.kwargs...)\n                        )\n                    catch err\n                        logging_error(logger, level, _module, group, id, file, line, err)\n                    end\n                end\n            end\n        end\n        nothing\n    end\n    end\nend\n\nfunction process_logmsg_exs(_orig_module, _file, _line, level, message, exs...)\n    local _group, _id\n    _module = _orig_module\n    kwargs = Any[]\n    for ex in exs\n        if ex isa Expr && ex.head === :(=)\n            k,v = ex.args\n            if !(k isa Symbol)\n                k = Symbol(k)\n            end\n\n            # Recognize several special keyword arguments\n            if k === :_group\n                _group = esc(v)\n            elseif k === :_id\n                _id = esc(v)\n            elseif k === :_module\n                _module = esc(v)\n            elseif k === :_file\n                _file = esc(v)\n            elseif k === :_line\n                _line = esc(v)\n            else\n                # Copy across key value pairs for structured log records\n                push!(kwargs, Expr(:kw, k, esc(v)))\n            end\n        elseif ex isa Expr && ex.head === :... # Keyword splatting\n            push!(kwargs, esc(ex))\n        else # Positional arguments - will be converted to key value pairs automatically.\n            push!(kwargs, Expr(:kw, Symbol(ex), esc(ex)))\n        end\n    end\n\n    if !@isdefined(_group)\n        _group = default_group_code(_file)\n    end\n    if !@isdefined(_id)\n        _id = Expr(:quote, log_record_id(_orig_module, level, message, exs))\n    end\n    return (;_module, _group, _id, _file, _line, kwargs)\nend\n\nfunction default_group_code(file)\n    if file isa String && isdefined(Base, :basename)\n        QuoteNode(default_group(file))  # precompute if we can\n    else\n        ref = Ref{Symbol}()  # memoized run-time execution\n        :(isassigned(\$ref) ? \$ref[] : \$ref[] = default_group(something(\$file, \"\")))\n    end\nend\n\n\n# Report an error in log message creation (or in the logger itself).\n@noinline function logging_error(logger, level, _module, group, id,\n                                 filepath, line, @nospecialize(err))\n    if !_invoked_catch_exceptions(logger)\n        rethrow(err)\n    end\n    try\n        msg = \"Exception while generating log record in module \$_module at \$filepath:\$line\"\n        handle_message(\n            logger, Error, msg, _module, :logevent_error, id, filepath, line;\n            exception=(err,catch_backtrace())\n        )\n    catch err2\n        try\n            # Give up and write to stderr, in three independent calls to\n            # increase the odds of it getting through.\n            print(stderr, \"Exception handling log message: \")\n            println(stderr, err)\n            println(stderr, \"  module=\$_module  file=\$filepath  line=\$line\")\n            println(stderr, \"  Second exception: \", err2)\n        catch\n        end\n    end\n    nothing\nend\n\n# Log a message. Called from the julia C code; kwargs is in the format\n# Any[key1,val1, ...] for simplicity in construction on the C side.\nfunction logmsg_shim(level, message, _module, group, id, file, line, kwargs)\n    real_kws = Any[(kwargs[i],kwargs[i+1]) for i in 1:2:length(kwargs)]\n    @logmsg(convert(LogLevel, level), message,\n            _module=_module, _id=id, _group=group,\n            _file=String(file), _line=line, real_kws...)\nend\n\n# Global log limiting mechanism for super fast but inflexible global log limiting.\nconst _min_enabled_level = Ref(Debug)\n\n# LogState - a cache of data extracted from the logger, plus the logger itself.\nstruct LogState\n    min_enabled_level::LogLevel\n    logger::AbstractLogger\nend\n\nLogState(logger) = LogState(LogLevel(_invoked_min_enabled_level(logger)), logger)\n\nfunction current_logstate()\n    logstate = current_task().logstate\n    return (logstate !== nothing ? logstate : _global_logstate)::LogState\nend\n\n# helper function to get the current logger, if enabled for the specified message type\n@noinline function current_logger_for_env(std_level::LogLevel, group, _module)\n    logstate = current_logstate()\n    if std_level >= logstate.min_enabled_level || env_override_minlevel(group, _module)\n        return logstate.logger\n    end\n    return nothing\nend\n\nfunction with_logstate(f::Function, logstate)\n    @nospecialize\n    t = current_task()\n    old = t.logstate\n    try\n        t.logstate = logstate\n        f()\n    finally\n        t.logstate = old\n    end\nend\n\n#-------------------------------------------------------------------------------\n# Control of the current logger and early log filtering\n\n\"\"\"\n    disable_logging(level)\n\nDisable all log messages at log levels equal to or less than `level`.  This is\na *global* setting, intended to make debug logging extremely cheap when\ndisabled.\n\n# Examples\n```\nLogging.disable_logging(Logging.Info) # Disable debug and info\n```\n\"\"\"\nfunction disable_logging(level::LogLevel)\n    _min_enabled_level[] = level + 1\nend\n\nlet _debug_groups_include::Vector{Symbol} = Symbol[],\n    _debug_groups_exclude::Vector{Symbol} = Symbol[],\n    _debug_str::String = \"\"\nglobal function env_override_minlevel(group, _module)\n    debug = get(ENV, \"JULIA_DEBUG\", \"\")\n    if !(debug === _debug_str)\n        _debug_str = debug\n        empty!(_debug_groups_include)\n        empty!(_debug_groups_exclude)\n        for g in split(debug, ',')\n            if !isempty(g)\n                if startswith(g, \"!\")\n                    if !isempty(g[2:end])\n                        push!(_debug_groups_exclude, Symbol(g[2:end]))\n                    end\n                else\n                    push!(_debug_groups_include, Symbol(g))\n                end\n            end\n        end\n        unique!(_debug_groups_include)\n        unique!(_debug_groups_exclude)\n    end\n\n    if !(:all in _debug_groups_exclude) && (:all in _debug_groups_include || !isempty(_debug_groups_exclude))\n        if isempty(_debug_groups_exclude)\n            return true\n        elseif isa(group, Symbol) && group in _debug_groups_exclude\n            return false\n        elseif isa(_module, Module) && (nameof(_module) in _debug_groups_exclude || nameof(Base.moduleroot(_module)) in _debug_groups_exclude)\n            return false\n        else\n            return true\n        end\n    else\n        if isempty(_debug_groups_include)\n            return false\n        elseif isa(group, Symbol) && group in _debug_groups_include\n            return true\n        elseif isa(_module, Module) && (nameof(_module) in _debug_groups_include || nameof(Base.moduleroot(_module)) in _debug_groups_include)\n            return true\n        else\n            return false\n        end\n    end\n    return false\nend\nend\n\n\n\"\"\"\n    global_logger()\n\nReturn the global logger, used to receive messages when no specific logger\nexists for the current task.\n\n    global_logger(logger)\n\nSet the global logger to `logger`, and return the previous global logger.\n\"\"\"\nglobal_logger() = _global_logstate.logger\n\nfunction global_logger(logger::AbstractLogger)\n    prev = _global_logstate.logger\n    global _global_logstate = LogState(logger)\n    prev\nend\n\n\"\"\"\n    with_logger(function, logger)\n\nExecute `function`, directing all log messages to `logger`.\n\n# Example\n\n```julia\nfunction test(x)\n    @info \"x = \\\$x\"\nend\n\nwith_logger(logger) do\n    test(1)\n    test([1,2])\nend\n```\n\"\"\"\nfunction with_logger(@nospecialize(f::Function), logger::AbstractLogger)\n    with_logstate(f, LogState(logger))\nend\n\n\"\"\"\n    current_logger()\n\nReturn the logger for the current task, or the global logger if none is\nattached to the task.\n\"\"\"\ncurrent_logger() = current_logstate().logger\n\n\n#-------------------------------------------------------------------------------\n# SimpleLogger\n\"\"\"\n    SimpleLogger(stream=stderr, min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to\n`min_level` to `stream`.\n\"\"\"\nstruct SimpleLogger <: AbstractLogger\n    stream::IO\n    min_level::LogLevel\n    message_limits::Dict{Any,Int}\nend\nSimpleLogger(stream::IO=stderr, level=Info) = SimpleLogger(stream, level, Dict{Any,Int}())\n\nshouldlog(logger::SimpleLogger, level, _module, group, id) =\n    get(logger.message_limits, id, 1) > 0\n\nmin_enabled_level(logger::SimpleLogger) = logger.min_level\n\ncatch_exceptions(logger::SimpleLogger) = false\n\nfunction handle_message(logger::SimpleLogger, level, message, _module, group, id,\n                        filepath, line; maxlog=nothing, kwargs...)\n    if maxlog !== nothing && maxlog isa Integer\n        remaining = get!(logger.message_limits, id, maxlog)\n        logger.message_limits[id] = remaining - 1\n        remaining > 0 || return\n    end\n    buf = IOBuffer()\n    iob = IOContext(buf, logger.stream)\n    levelstr = level == Warn ? \"Warning\" : string(level)\n    msglines = split(chomp(string(message)), '\\n')\n    println(iob, \"┌ \", levelstr, \": \", msglines[1])\n    for i in 2:length(msglines)\n        println(iob, \"│ \", msglines[i])\n    end\n    for (key, val) in kwargs\n        println(iob, \"│   \", key, \" = \", val)\n    end\n    println(iob, \"└ @ \", something(_module, \"nothing\"), \" \",\n            something(filepath, \"nothing\"), \":\", something(line, \"nothing\"))\n    write(logger.stream, take!(buf))\n    nothing\nend\n\n_global_logstate = LogState(SimpleLogger(Core.stderr, CoreLogging.Info))\n\nend # CoreLogging\n")
ERROR: LoadError: LoadError: There was an error during testing
in expression starting at /home/pkgeval/.julia/packages/Debugger/W9gho/test/misc.jl:60
in expression starting at /home/pkgeval/.julia/packages/Debugger/W9gho/test/runtests.jl:18
ERROR: Package Debugger errored during testing
Stacktrace:
  [1] pkgerror(::String, ::Vararg{String, N} where N)
    @ Pkg.Types /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:52
  [2] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing)
    @ Pkg.Operations /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1580
  [3] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})
    @ Pkg.API /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:328
  [4] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec})
    @ Pkg.API /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:315
  [5] #test#62
    @ /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:67 [inlined]
  [6] test
    @ /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:67 [inlined]
  [7] #test#61
    @ /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:66 [inlined]
  [8] test
    @ /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:66 [inlined]
  [9] test(pkg::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})
    @ Pkg.API /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:65
 [10] test(pkg::String)
    @ Pkg.API /workspace/srcdir/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:65
 [11] top-level scope
    @ none:19
